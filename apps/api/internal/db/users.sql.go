// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  wallet_address, email, role, full_name, password_hash
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email
`

type CreateUserParams struct {
	WalletAddress pgtype.Text `json:"wallet_address"`
	Email         pgtype.Text `json:"email"`
	Role          UserRole    `json:"role"`
	FullName      pgtype.Text `json:"full_name"`
	PasswordHash  pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.WalletAddress,
		arg.Email,
		arg.Role,
		arg.FullName,
		arg.PasswordHash,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}

const getUserByWallet = `-- name: GetUserByWallet :one
SELECT id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email FROM users WHERE wallet_address = $1 LIMIT 1
`

func (q *Queries) GetUserByWallet(ctx context.Context, walletAddress pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByWallet, walletAddress)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}

const searchCandidates = `-- name: SearchCandidates :many
SELECT id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email FROM users 
WHERE role = 'CANDIDATE' 
  AND (
    to_tsvector('english', 
      COALESCE(full_name, '') || ' ' || 
      COALESCE(skills, '') || ' ' || 
      COALESCE(job_role, '') || ' ' || 
      COALESCE(bio, '')
    ) @@ websearch_to_tsquery('english', $1)
    OR
    -- Fallback for partial word matches (e.g. 'Reac' matching 'React') which TSVECTOR might miss if not stemmed
    full_name ILIKE '%' || $1 || '%' OR
    skills ILIKE '%' || $1 || '%'
  )
LIMIT 20
`

func (q *Queries) SearchCandidates(ctx context.Context, websearchToTsquery string) ([]User, error) {
	rows, err := q.db.Query(ctx, searchCandidates, websearchToTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.WalletAddress,
			&i.Email,
			&i.Role,
			&i.Karma,
			&i.IsPro,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FullName,
			&i.PasswordHash,
			&i.Bio,
			&i.Skills,
			&i.Experience,
			&i.Projects,
			&i.JobRole,
			&i.Education,
			&i.Phone,
			&i.OrganizationName,
			&i.OrganizationLocation,
			&i.OrganizationBio,
			&i.ProfessionalEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecruiterProfile = `-- name: UpdateRecruiterProfile :one
UPDATE users
SET 
  full_name = COALESCE($2, full_name),
  -- email = COALESCE($3, email), <-- REMOVED
  phone = COALESCE($3, phone),
  organization_name = COALESCE($4, organization_name),
  organization_location = COALESCE($5, organization_location),
  organization_bio = COALESCE($6, organization_bio),
  bio = COALESCE($7, bio),
  skills = COALESCE($8, skills),
  experience = COALESCE($9, experience),
  education = COALESCE($10, education),
  job_role = COALESCE($11, job_role),
  professional_email = COALESCE($12, professional_email) -- <-- NEW
WHERE id = $1
RETURNING id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email
`

type UpdateRecruiterProfileParams struct {
	ID                   pgtype.UUID `json:"id"`
	FullName             pgtype.Text `json:"full_name"`
	Phone                pgtype.Text `json:"phone"`
	OrganizationName     pgtype.Text `json:"organization_name"`
	OrganizationLocation pgtype.Text `json:"organization_location"`
	OrganizationBio      pgtype.Text `json:"organization_bio"`
	Bio                  pgtype.Text `json:"bio"`
	Skills               pgtype.Text `json:"skills"`
	Experience           pgtype.Text `json:"experience"`
	Education            pgtype.Text `json:"education"`
	JobRole              pgtype.Text `json:"job_role"`
	ProfessionalEmail    pgtype.Text `json:"professional_email"`
}

func (q *Queries) UpdateRecruiterProfile(ctx context.Context, arg UpdateRecruiterProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateRecruiterProfile,
		arg.ID,
		arg.FullName,
		arg.Phone,
		arg.OrganizationName,
		arg.OrganizationLocation,
		arg.OrganizationBio,
		arg.Bio,
		arg.Skills,
		arg.Experience,
		arg.Education,
		arg.JobRole,
		arg.ProfessionalEmail,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}

const updateSeekerProfile = `-- name: UpdateSeekerProfile :one
UPDATE users
SET 
  full_name = COALESCE($2, full_name),
  -- email = COALESCE($3, email),  <-- REMOVED: Don't update login email here
  bio = COALESCE($3, bio),
  skills = COALESCE($4, skills),
  experience = COALESCE($5, experience),
  projects = COALESCE($6, projects),
  education = COALESCE($7, education),
  job_role = COALESCE($8, job_role),
  professional_email = COALESCE($9, professional_email) -- <-- NEW
WHERE id = $1
RETURNING id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education, phone, organization_name, organization_location, organization_bio, professional_email
`

type UpdateSeekerProfileParams struct {
	ID                pgtype.UUID `json:"id"`
	FullName          pgtype.Text `json:"full_name"`
	Bio               pgtype.Text `json:"bio"`
	Skills            pgtype.Text `json:"skills"`
	Experience        pgtype.Text `json:"experience"`
	Projects          []byte      `json:"projects"`
	Education         pgtype.Text `json:"education"`
	JobRole           pgtype.Text `json:"job_role"`
	ProfessionalEmail pgtype.Text `json:"professional_email"`
}

func (q *Queries) UpdateSeekerProfile(ctx context.Context, arg UpdateSeekerProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateSeekerProfile,
		arg.ID,
		arg.FullName,
		arg.Bio,
		arg.Skills,
		arg.Experience,
		arg.Projects,
		arg.Education,
		arg.JobRole,
		arg.ProfessionalEmail,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
		&i.Phone,
		&i.OrganizationName,
		&i.OrganizationLocation,
		&i.OrganizationBio,
		&i.ProfessionalEmail,
	)
	return i, err
}
