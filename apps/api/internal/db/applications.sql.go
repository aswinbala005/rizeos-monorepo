// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
  job_id, candidate_id, status, match_score, gateway_answer
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, job_id, candidate_id, status, match_score, gateway_answer, created_at, updated_at
`

type CreateApplicationParams struct {
	JobID         pgtype.UUID `json:"job_id"`
	CandidateID   pgtype.UUID `json:"candidate_id"`
	Status        string      `json:"status"`
	MatchScore    pgtype.Int4 `json:"match_score"`
	GatewayAnswer pgtype.Text `json:"gateway_answer"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.JobID,
		arg.CandidateID,
		arg.Status,
		arg.MatchScore,
		arg.GatewayAnswer,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.CandidateID,
		&i.Status,
		&i.MatchScore,
		&i.GatewayAnswer,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications WHERE id = $1
`

func (q *Queries) DeleteApplication(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplication, id)
	return err
}

const getAllApplicationsByRecruiter = `-- name: GetAllApplicationsByRecruiter :many
SELECT 
    a.id, 
    a.status, 
    a.created_at, 
    a.match_score,
    a.gateway_answer,
    a.job_id, -- <--- ADDED THIS
    j.title as job_title,
    u.id as candidate_id,
    u.full_name as candidate_name,
    u.email as candidate_email,
    u.job_role as candidate_role,
    u.skills as candidate_skills,
    u.education as candidate_education, -- <--- ADDED THIS
    u.experience as candidate_experience
FROM applications a
JOIN jobs j ON a.job_id = j.id
JOIN users u ON a.candidate_id = u.id
WHERE j.recruiter_id = $1
ORDER BY a.match_score DESC
`

type GetAllApplicationsByRecruiterRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Status              string             `json:"status"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	MatchScore          pgtype.Int4        `json:"match_score"`
	GatewayAnswer       pgtype.Text        `json:"gateway_answer"`
	JobID               pgtype.UUID        `json:"job_id"`
	JobTitle            string             `json:"job_title"`
	CandidateID         pgtype.UUID        `json:"candidate_id"`
	CandidateName       pgtype.Text        `json:"candidate_name"`
	CandidateEmail      pgtype.Text        `json:"candidate_email"`
	CandidateRole       pgtype.Text        `json:"candidate_role"`
	CandidateSkills     pgtype.Text        `json:"candidate_skills"`
	CandidateEducation  pgtype.Text        `json:"candidate_education"`
	CandidateExperience pgtype.Text        `json:"candidate_experience"`
}

func (q *Queries) GetAllApplicationsByRecruiter(ctx context.Context, recruiterID pgtype.UUID) ([]GetAllApplicationsByRecruiterRow, error) {
	rows, err := q.db.Query(ctx, getAllApplicationsByRecruiter, recruiterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllApplicationsByRecruiterRow
	for rows.Next() {
		var i GetAllApplicationsByRecruiterRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CreatedAt,
			&i.MatchScore,
			&i.GatewayAnswer,
			&i.JobID,
			&i.JobTitle,
			&i.CandidateID,
			&i.CandidateName,
			&i.CandidateEmail,
			&i.CandidateRole,
			&i.CandidateSkills,
			&i.CandidateEducation,
			&i.CandidateExperience,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationVolumeByRecruiter = `-- name: GetApplicationVolumeByRecruiter :many
SELECT 
    DATE(a.created_at)::text as application_date,
    COUNT(*) as total
FROM applications a
JOIN jobs j ON a.job_id = j.id
WHERE j.recruiter_id = $1
  AND EXTRACT(MONTH FROM a.created_at) = EXTRACT(MONTH FROM CURRENT_DATE)
  AND EXTRACT(YEAR FROM a.created_at) = EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY application_date
ORDER BY application_date ASC
`

type GetApplicationVolumeByRecruiterRow struct {
	ApplicationDate string `json:"application_date"`
	Total           int64  `json:"total"`
}

func (q *Queries) GetApplicationVolumeByRecruiter(ctx context.Context, recruiterID pgtype.UUID) ([]GetApplicationVolumeByRecruiterRow, error) {
	rows, err := q.db.Query(ctx, getApplicationVolumeByRecruiter, recruiterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationVolumeByRecruiterRow
	for rows.Next() {
		var i GetApplicationVolumeByRecruiterRow
		if err := rows.Scan(&i.ApplicationDate, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByCandidate = `-- name: GetApplicationsByCandidate :many
SELECT 
    a.id, 
    a.status, 
    a.created_at, 
    a.match_score,
    j.title as job_title, 
    j.description as job_description,
    u.organization_name as company_name -- <--- Get this from the USERS table
FROM applications a
JOIN jobs j ON a.job_id = j.id
JOIN users u ON j.recruiter_id = u.id -- <--- JOIN to link Job -> Recruiter
WHERE a.candidate_id = $1
ORDER BY a.created_at DESC
`

type GetApplicationsByCandidateRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	MatchScore     pgtype.Int4        `json:"match_score"`
	JobTitle       string             `json:"job_title"`
	JobDescription string             `json:"job_description"`
	CompanyName    pgtype.Text        `json:"company_name"`
}

func (q *Queries) GetApplicationsByCandidate(ctx context.Context, candidateID pgtype.UUID) ([]GetApplicationsByCandidateRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsByCandidate, candidateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsByCandidateRow
	for rows.Next() {
		var i GetApplicationsByCandidateRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CreatedAt,
			&i.MatchScore,
			&i.JobTitle,
			&i.JobDescription,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsByJob = `-- name: GetApplicationsByJob :many
SELECT 
    a.id, 
    a.status, 
    a.created_at, 
    a.match_score,
    a.gateway_answer,
    u.full_name as candidate_name,
    u.email as candidate_email,
    u.job_role as candidate_role,
    u.skills as candidate_skills,
    u.experience as candidate_experience
FROM applications a
JOIN users u ON a.candidate_id = u.id
WHERE a.job_id = $1
ORDER BY a.match_score DESC
`

type GetApplicationsByJobRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Status              string             `json:"status"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	MatchScore          pgtype.Int4        `json:"match_score"`
	GatewayAnswer       pgtype.Text        `json:"gateway_answer"`
	CandidateName       pgtype.Text        `json:"candidate_name"`
	CandidateEmail      pgtype.Text        `json:"candidate_email"`
	CandidateRole       pgtype.Text        `json:"candidate_role"`
	CandidateSkills     pgtype.Text        `json:"candidate_skills"`
	CandidateExperience pgtype.Text        `json:"candidate_experience"`
}

func (q *Queries) GetApplicationsByJob(ctx context.Context, jobID pgtype.UUID) ([]GetApplicationsByJobRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsByJobRow
	for rows.Next() {
		var i GetApplicationsByJobRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CreatedAt,
			&i.MatchScore,
			&i.GatewayAnswer,
			&i.CandidateName,
			&i.CandidateEmail,
			&i.CandidateRole,
			&i.CandidateSkills,
			&i.CandidateExperience,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
