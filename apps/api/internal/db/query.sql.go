// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
  job_id,
  candidate_id,
  status,
  match_score,
  gateway_answer
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, job_id, candidate_id, status, match_score, gateway_answer, gateway_grade, created_at, updated_at
`

type CreateApplicationParams struct {
	JobID         pgtype.UUID `json:"job_id"`
	CandidateID   pgtype.UUID `json:"candidate_id"`
	Status        string      `json:"status"`
	MatchScore    pgtype.Int4 `json:"match_score"`
	GatewayAnswer pgtype.Text `json:"gateway_answer"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.JobID,
		arg.CandidateID,
		arg.Status,
		arg.MatchScore,
		arg.GatewayAnswer,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.CandidateID,
		&i.Status,
		&i.MatchScore,
		&i.GatewayAnswer,
		&i.GatewayGrade,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
  recruiter_id,
  title,
  description,
  gateway_question,
  is_paid
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, recruiter_id, title, description, gateway_question, is_paid, created_at, updated_at
`

type CreateJobParams struct {
	RecruiterID     pgtype.UUID `json:"recruiter_id"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	GatewayQuestion pgtype.Text `json:"gateway_question"`
	IsPaid          pgtype.Bool `json:"is_paid"`
}

type CreateJobRow struct {
	ID              pgtype.UUID        `json:"id"`
	RecruiterID     pgtype.UUID        `json:"recruiter_id"`
	Title           string             `json:"title"`
	Description     string             `json:"description"`
	GatewayQuestion pgtype.Text        `json:"gateway_question"`
	IsPaid          pgtype.Bool        `json:"is_paid"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (CreateJobRow, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.RecruiterID,
		arg.Title,
		arg.Description,
		arg.GatewayQuestion,
		arg.IsPaid,
	)
	var i CreateJobRow
	err := row.Scan(
		&i.ID,
		&i.RecruiterID,
		&i.Title,
		&i.Description,
		&i.GatewayQuestion,
		&i.IsPaid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  wallet_address,
  email,
  role,
  full_name,
  password_hash
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education
`

type CreateUserParams struct {
	WalletAddress pgtype.Text `json:"wallet_address"`
	Email         pgtype.Text `json:"email"`
	Role          UserRole    `json:"role"`
	FullName      pgtype.Text `json:"full_name"`
	PasswordHash  pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.WalletAddress,
		arg.Email,
		arg.Role,
		arg.FullName,
		arg.PasswordHash,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1
`

func (q *Queries) DeleteApplication(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplication, id)
	return err
}

const getApplicationsByCandidate = `-- name: GetApplicationsByCandidate :many
SELECT 
    a.id, a.status, a.created_at, a.match_score,
    j.title as job_title, 
    j.description as job_description
FROM applications a
JOIN jobs j ON a.job_id = j.id
WHERE a.candidate_id = $1
ORDER BY a.created_at DESC
`

type GetApplicationsByCandidateRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	MatchScore     pgtype.Int4        `json:"match_score"`
	JobTitle       string             `json:"job_title"`
	JobDescription string             `json:"job_description"`
}

func (q *Queries) GetApplicationsByCandidate(ctx context.Context, candidateID pgtype.UUID) ([]GetApplicationsByCandidateRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsByCandidate, candidateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsByCandidateRow
	for rows.Next() {
		var i GetApplicationsByCandidateRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CreatedAt,
			&i.MatchScore,
			&i.JobTitle,
			&i.JobDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByWallet = `-- name: GetUserByWallet :one
SELECT id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education FROM users
WHERE wallet_address = $1 LIMIT 1
`

func (q *Queries) GetUserByWallet(ctx context.Context, walletAddress pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByWallet, walletAddress)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT 
  id, 
  recruiter_id, 
  title, 
  description, 
  gateway_question, 
  is_paid, 
  created_at, 
  updated_at 
FROM jobs
ORDER BY created_at DESC
`

type ListJobsRow struct {
	ID              pgtype.UUID        `json:"id"`
	RecruiterID     pgtype.UUID        `json:"recruiter_id"`
	Title           string             `json:"title"`
	Description     string             `json:"description"`
	GatewayQuestion pgtype.Text        `json:"gateway_question"`
	IsPaid          pgtype.Bool        `json:"is_paid"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListJobs(ctx context.Context) ([]ListJobsRow, error) {
	rows, err := q.db.Query(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecruiterID,
			&i.Title,
			&i.Description,
			&i.GatewayQuestion,
			&i.IsPaid,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
  full_name = COALESCE($2, full_name),
  email = COALESCE($3, email),
  bio = COALESCE($4, bio),
  skills = COALESCE($5, skills),
  experience = COALESCE($6, experience),
  projects = COALESCE($7, projects),
  education = COALESCE($8, education),
  job_role = COALESCE($9, job_role) -- <-- NEW
WHERE id = $1
RETURNING id, wallet_address, email, role, karma, is_pro, created_at, updated_at, full_name, password_hash, bio, skills, experience, projects, job_role, education
`

type UpdateUserParams struct {
	ID         pgtype.UUID `json:"id"`
	FullName   pgtype.Text `json:"full_name"`
	Email      pgtype.Text `json:"email"`
	Bio        pgtype.Text `json:"bio"`
	Skills     pgtype.Text `json:"skills"`
	Experience pgtype.Text `json:"experience"`
	Projects   pgtype.Text `json:"projects"`
	Education  pgtype.Text `json:"education"`
	JobRole    pgtype.Text `json:"job_role"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.Bio,
		arg.Skills,
		arg.Experience,
		arg.Projects,
		arg.Education,
		arg.JobRole,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.WalletAddress,
		&i.Email,
		&i.Role,
		&i.Karma,
		&i.IsPro,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FullName,
		&i.PasswordHash,
		&i.Bio,
		&i.Skills,
		&i.Experience,
		&i.Projects,
		&i.JobRole,
		&i.Education,
	)
	return i, err
}
