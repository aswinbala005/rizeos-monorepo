// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeJob = `-- name: CloseJob :exec
UPDATE jobs SET status = 'CLOSED' WHERE id = $1
`

func (q *Queries) CloseJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, closeJob, id)
	return err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
  recruiter_id, title, description, requirements, is_paid,
  job_type, location_type, location_city, salary_min, salary_max, currency,
  experience_min, experience_max, benefits,
  job_summary, education_requirements, skills_requirements, is_unpaid,
  recruiter_email
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
)
RETURNING id, recruiter_id, title, description, is_paid, created_at, updated_at
`

type CreateJobParams struct {
	RecruiterID           pgtype.UUID `json:"recruiter_id"`
	Title                 string      `json:"title"`
	Description           string      `json:"description"`
	Requirements          pgtype.Text `json:"requirements"`
	IsPaid                pgtype.Bool `json:"is_paid"`
	JobType               pgtype.Text `json:"job_type"`
	LocationType          pgtype.Text `json:"location_type"`
	LocationCity          pgtype.Text `json:"location_city"`
	SalaryMin             pgtype.Int4 `json:"salary_min"`
	SalaryMax             pgtype.Int4 `json:"salary_max"`
	Currency              pgtype.Text `json:"currency"`
	ExperienceMin         pgtype.Int4 `json:"experience_min"`
	ExperienceMax         pgtype.Int4 `json:"experience_max"`
	Benefits              pgtype.Text `json:"benefits"`
	JobSummary            pgtype.Text `json:"job_summary"`
	EducationRequirements pgtype.Text `json:"education_requirements"`
	SkillsRequirements    pgtype.Text `json:"skills_requirements"`
	IsUnpaid              pgtype.Bool `json:"is_unpaid"`
	RecruiterEmail        pgtype.Text `json:"recruiter_email"`
}

type CreateJobRow struct {
	ID          pgtype.UUID        `json:"id"`
	RecruiterID pgtype.UUID        `json:"recruiter_id"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	IsPaid      pgtype.Bool        `json:"is_paid"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (CreateJobRow, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.RecruiterID,
		arg.Title,
		arg.Description,
		arg.Requirements,
		arg.IsPaid,
		arg.JobType,
		arg.LocationType,
		arg.LocationCity,
		arg.SalaryMin,
		arg.SalaryMax,
		arg.Currency,
		arg.ExperienceMin,
		arg.ExperienceMax,
		arg.Benefits,
		arg.JobSummary,
		arg.EducationRequirements,
		arg.SkillsRequirements,
		arg.IsUnpaid,
		arg.RecruiterEmail,
	)
	var i CreateJobRow
	err := row.Scan(
		&i.ID,
		&i.RecruiterID,
		&i.Title,
		&i.Description,
		&i.IsPaid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobApplicationCounts = `-- name: GetJobApplicationCounts :many
SELECT 
    j.id,
    j.title,
    j.status,
    COUNT(a.id)::int as applicant_count
FROM jobs j
LEFT JOIN applications a ON j.id = a.job_id
WHERE j.recruiter_id = $1
GROUP BY j.id
ORDER BY applicant_count DESC
`

type GetJobApplicationCountsRow struct {
	ID             pgtype.UUID `json:"id"`
	Title          string      `json:"title"`
	Status         pgtype.Text `json:"status"`
	ApplicantCount int32       `json:"applicant_count"`
}

func (q *Queries) GetJobApplicationCounts(ctx context.Context, recruiterID pgtype.UUID) ([]GetJobApplicationCountsRow, error) {
	rows, err := q.db.Query(ctx, getJobApplicationCounts, recruiterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationCountsRow
	for rows.Next() {
		var i GetJobApplicationCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.ApplicantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, recruiter_id, title, description, is_paid, created_at, updated_at, job_type, location_type, location_city, salary_min, salary_max, currency, experience_min, experience_max, benefits, requirements, job_summary, education_requirements, skills_requirements, is_unpaid, recruiter_email, status FROM jobs WHERE id = $1 LIMIT 1
`

func (q *Queries) GetJobByID(ctx context.Context, id pgtype.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.RecruiterID,
		&i.Title,
		&i.Description,
		&i.IsPaid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobType,
		&i.LocationType,
		&i.LocationCity,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.Currency,
		&i.ExperienceMin,
		&i.ExperienceMax,
		&i.Benefits,
		&i.Requirements,
		&i.JobSummary,
		&i.EducationRequirements,
		&i.SkillsRequirements,
		&i.IsUnpaid,
		&i.RecruiterEmail,
		&i.Status,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT 
  j.id, j.recruiter_id, j.title, j.description, j.is_paid, j.created_at, j.updated_at,
  j.job_type, j.location_type, j.location_city, j.salary_min, j.salary_max, j.currency,
  j.job_summary, j.education_requirements, j.skills_requirements, j.is_unpaid,
  u.organization_name
FROM jobs j
JOIN users u ON j.recruiter_id = u.id
WHERE status = 'OPEN'
ORDER BY j.created_at DESC
`

type ListJobsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	RecruiterID           pgtype.UUID        `json:"recruiter_id"`
	Title                 string             `json:"title"`
	Description           string             `json:"description"`
	IsPaid                pgtype.Bool        `json:"is_paid"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	JobType               pgtype.Text        `json:"job_type"`
	LocationType          pgtype.Text        `json:"location_type"`
	LocationCity          pgtype.Text        `json:"location_city"`
	SalaryMin             pgtype.Int4        `json:"salary_min"`
	SalaryMax             pgtype.Int4        `json:"salary_max"`
	Currency              pgtype.Text        `json:"currency"`
	JobSummary            pgtype.Text        `json:"job_summary"`
	EducationRequirements pgtype.Text        `json:"education_requirements"`
	SkillsRequirements    pgtype.Text        `json:"skills_requirements"`
	IsUnpaid              pgtype.Bool        `json:"is_unpaid"`
	OrganizationName      pgtype.Text        `json:"organization_name"`
}

func (q *Queries) ListJobs(ctx context.Context) ([]ListJobsRow, error) {
	rows, err := q.db.Query(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecruiterID,
			&i.Title,
			&i.Description,
			&i.IsPaid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobType,
			&i.LocationType,
			&i.LocationCity,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.Currency,
			&i.JobSummary,
			&i.EducationRequirements,
			&i.SkillsRequirements,
			&i.IsUnpaid,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByRecruiter = `-- name: ListJobsByRecruiter :many
SELECT 
  id, title, created_at, location_city, location_type,
  salary_min, salary_max, currency, is_unpaid, skills_requirements,
  status -- <-- NEW FIELD
FROM jobs
WHERE recruiter_id = $1
ORDER BY created_at DESC
`

type ListJobsByRecruiterRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Title              string             `json:"title"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	LocationCity       pgtype.Text        `json:"location_city"`
	LocationType       pgtype.Text        `json:"location_type"`
	SalaryMin          pgtype.Int4        `json:"salary_min"`
	SalaryMax          pgtype.Int4        `json:"salary_max"`
	Currency           pgtype.Text        `json:"currency"`
	IsUnpaid           pgtype.Bool        `json:"is_unpaid"`
	SkillsRequirements pgtype.Text        `json:"skills_requirements"`
	Status             pgtype.Text        `json:"status"`
}

func (q *Queries) ListJobsByRecruiter(ctx context.Context, recruiterID pgtype.UUID) ([]ListJobsByRecruiterRow, error) {
	rows, err := q.db.Query(ctx, listJobsByRecruiter, recruiterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsByRecruiterRow
	for rows.Next() {
		var i ListJobsByRecruiterRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.LocationCity,
			&i.LocationType,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.Currency,
			&i.IsUnpaid,
			&i.SkillsRequirements,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reopenJob = `-- name: ReopenJob :exec
UPDATE jobs SET status = 'OPEN' WHERE id = $1
`

func (q *Queries) ReopenJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, reopenJob, id)
	return err
}
